# 设计模式
<!-- GFM-TOC -->
* [单例模式](#单例模式)
* [工厂模式](#工厂模式)
* [责任链模式](#责任链模式)
* [策略模式](#策略模式)
* [观察者模式](#观察者模式)
* [享元模式](#享元模式)
* [代理模式（重要！！！）](#代理模式)
* [迭代器模式](#迭代器模式)
* [参考] #https://www.bilibili.com/video/BV1tK411W7xx?p=16
<!-- GFM-TOC -->
### 单例模式
    单例模式是生成对象的最佳是实践，一个类只有唯一的对象，生成对象的方法也在这个类中，直接调用方法来生成类，不需要自己new
    懒汉式： class Singe{
            private static Singe INSTANCE=new Singe();
            private Singe(){
            }
            public Singe getInstance(){
                return INSTANCE;
            }
    }
    缺点：无法进行懒加载，对象在类加载的时候就会生成
    
    饿汉式： class Singe{
           private  Singe INSTANCE;
           private Singe(){}
           public static getIstance(){
                if(INSTANCE==null){
                    return new Singe();
                }
                return INSTANCE;
           } 
    }
    缺点：线程不安全
    
    双重检查
    class Singe{
        private volatile Singe INSTANCE;
        private Singe INSTANCE;
        
        public Singe getInstance(){
            if(INSTANCE==null){
            synchronsized(Singe.class){
               if(INSTANCE==null){
                    return new INSTANCE;
               }
            }
            return INSTANCE
            }
        }
    }
    
    还有静态内部类和枚举的写法就去看项目里面的代码吧
### 工厂模式
    同样是生成对象的设计模式
    
#### 简单工厂模式
     抽象类：抽象出来属性相同的类，声明抽象方法
     子类：实现抽象类，生成自己的个性化需求
     factory：通过type来判断自己要初始化什么类，所以会有很多的if else
     
#### 工厂模版模式
     抽象类：抽象出来属性相同的类，声明抽象方法
     子类：实现抽象类，生成自己的个性化需求
     factory：创建不同类的声明方法，不用太多if else
     
#### 抽象工厂
     抽象工厂主要是用来方便不同的产品族生成对象
     抽象类：抽象出来属性相同的类，声明抽象方法
     子类：实现抽象类，生成自己的个性化需求   
     抽象工厂：抽象出不同产品族的方法
     factory：继承抽象工厂，创建不同类的声明方法，不用太多if else
     具体看项目代码

### 责任链模式
    通过链式方法来处理某一资源，如数据清洗
    接口：filter 定义责任链的共同抽象方法
    子类：实现抽象类，完成自己的职责
    chain：声明filter的list的成员变量 并实现doFiter方法，遍历成员遍历list，调用item的方法
    （可以让chain也实现抽象类，方便两条责任链合并）
    具体看项目代码
          
### 策略模式
    用于同一个资源可以使用不同的方法来处理
    接口：定义策略  一般使用范型
    策略子类：实现接口，生成不同策略
    处理策略类：处理方法的参数为接口，用于接受不同的策略
    具体看项目代码
    
### 观察者模式
    观察者接口：声明actionMethod，也就是被观察者发生情况调用的方法，参数为事件类（Event），通过事件确认被观察者的状态做出反应
    被观察者：声明观察者list成员变量，事件的成员变量，声明检测到被观察发生情况的调用方法，使用list的item调用观察者方法
    事件类：绑定在被观察者中，声明被观察者需要被观察者了解的属性
    具体查看项目代码
   
### 组合模式
    组合模式常常用于创建对象组的树行结构
    接口：声明node接口
    left节点：实现接口
    right节点：实现接口
    父亲节点：实现接口，并声明node的list的成员变量
    通过这些对象可以组合成一颗树的大对象
    具体查看项目代码

### 享元模式
    同享元对象，不用去new，去对象池子里面去取对象，不要去new
    对象类  声明对象的属性与方法
    对象pool 在其中new 对象，外界从该池子中获取对象
    具体查看项目代码

### 代理模式
    设置代理来控制对这个对象的访问，通过代理类的加上一层访问层，来访问对象你想要访问方法
    可以通过代理在你想要调用的方法，加上after与before代码
    接口：抽象出对象的抽象方法
    对象：实现接口
    proxy类：实现并且组合接口类，通过接口的方法来实现自己想完成的事情，提供给外界来使用
    具体查看项目代码
    
#### 动态代理（jdk）
     必须面向接口
     使用反射去二进制字节码中获类的属性与方法，调用handler对对象进行代理
     代理类:实现invcoationHandler接口，实现invoke方法
     接口：抽象方法
     对象类：实现抽象方法
     客户端调用动态代理：new proxy.newPorxyInstance(对象类.class.classload,new class[]{接口.class},代理类)
     该方法会返回接口的对象实例m，可以强转
     使用m.接口的方法名，使用动态代理
     具体查看项目代码
     
#### 动态代理（Cgilb）
      对象不需要面向接口 final修饰的类无法代理
      代理类：实现MethodInterceptor
      客户端：Enhancer enhancer = new Enhancer();
             enhancer.setSuperclass(TankMovable.class);
             enhancer.setCallback(new myCglibInterceptor());
       具体查看项目代码

#### AOP（面向切面编程）
      举个栗子，当我们完成一个复杂的功能实现的时候，不想去改他的时候，就可以使用动态代理，来生成before method和
      after method来进行切入代码中，这同时也是spring的重要性质之一
      通常我们可以在配置文件中就完成对aop的过程，设置切点，设置before与after
      当然也可以使用注解，更方便的完成aop
      由于ioc的bean的灵活装配与aop动态切入拼接，使得spring成为java世界的霸主
      
###  迭代器模式
     该模式代码参考jdk源码
     每一个容器实现iterator接口实现hasNext() 与next()方法
     通过这个就可以多态遍历集合
     因为数组可以用下标进行遍历，但是非线性链表就只能用指针遍历，使用迭代器可以用通用各种集合的遍历

###  

