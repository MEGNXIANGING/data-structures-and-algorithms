# 设计模式
<!-- GFM-TOC -->
* [单例模式](#单例模式)
* [工厂模式](#工厂模式)
* [责任链模式](#责任链模式)
* [策略模式](#策略模式)
* [观察者模式](#观察者模式)
* [参考] #https://www.bilibili.com/video/BV1tK411W7xx?p=16
<!-- GFM-TOC -->
### 单例模式
    单例模式是生成对象的最佳是实践，一个类只有唯一的对象，生成对象的方法也在这个类中，直接调用方法来生成类，不需要自己new
    懒汉式： class Singe{
            private static Singe INSTANCE=new Singe();
            private Singe(){
            }
            public Singe getInstance(){
                return INSTANCE;
            }
    }
    缺点：无法进行懒加载，对象在类加载的时候就会生成
    
    饿汉式： class Singe{
           private  Singe INSTANCE;
           private Singe(){}
           public static getIstance(){
                if(INSTANCE==null){
                    return new Singe();
                }
                return INSTANCE;
           } 
    }
    缺点：线程不安全
    
    双重检查
    class Singe{
        private volatile Singe INSTANCE;
        private Singe INSTANCE;
        
        public Singe getInstance(){
            if(INSTANCE==null){
            synchronsized(Singe.class){
               if(INSTANCE==null){
                    return new INSTANCE;
               }
            }
            return INSTANCE
            }
        }
    }
    
    还有静态内部类和枚举的写法就去看项目里面的代码吧
### 工厂模式
    同样是生成对象的设计模式
    
#### 简单工厂模式
     抽象类：抽象出来属性相同的类，声明抽象方法
     子类：实现抽象类，生成自己的个性化需求
     factory：通过type来判断自己要初始化什么类，所以会有很多的if else
     
#### 工厂模版模式
     抽象类：抽象出来属性相同的类，声明抽象方法
     子类：实现抽象类，生成自己的个性化需求
     factory：创建不同类的声明方法，不用太多if else
     
#### 抽象工厂
     抽象工厂主要是用来方便不同的产品族生成对象
     抽象类：抽象出来属性相同的类，声明抽象方法
     子类：实现抽象类，生成自己的个性化需求   
     抽象工厂：抽象出不同产品族的方法
     factory：继承抽象工厂，创建不同类的声明方法，不用太多if else
     具体看项目代码

### 责任链模式
    通过链式方法来处理某一资源，如数据清洗
    接口：filter 定义责任链的共同抽象方法
    子类：实现抽象类，完成自己的职责
    chain：声明filter的list的成员变量 并实现doFiter方法，遍历成员遍历list，调用item的方法
    （可以让chain也实现抽象类，方便两条责任链合并）
    具体看项目代码
          
### 策略模式
    用于同一个资源可以使用不同的方法来处理
    接口：定义策略  一般使用范型
    策略子类：实现接口，生成不同策略
    处理策略类：处理方法的参数为接口，用于接受不同的策略
    具体看项目代码
    
### 观察者模式


    