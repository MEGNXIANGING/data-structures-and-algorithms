# 多线程与JVM(持续更新)
   代码都可以在src/main/java/jucJvm包下找到哦
<!-- GFM-TOC -->
* [JMM概览](#JMM概览)
* [volatile关键字](# volatile关键字)
* [CAS](# CAS)
* [lock锁](# lock锁)
* [Synchronized](# Synchronized)
* [参考] #https://www.bilibili.com/video/BV18b411M7xz?p=12
<!-- GFM-TOC --> 
### JMM概览
    java内存模型，俗称JMM(java memory model)本生是一种抽象的概念，它用于描述一种规范：
        1、线程解锁之前，必须把共享变量的值刷回主内存
        2、线程加锁之前，必须从主内存中读取最新的值到线程工作内存
        3、加锁解锁是同一种锁 
    主内存：所有的java线程共享的共同存储空间，线程之间的通信是由主线程来完成的
    线程工作内存：线程私有的存储空间，该线程工作时，先从主内存中获取想要操作的变量的值，线程操作以后再刷新回主内存
### volatile关键字
    volatile 被用于单例模式的双重检查中，他的防止指令重排被用到该模式中
    
#### 保证可见性
     线程工作要操作变量的结果及时刷新回主内存，并通知其他持有该变量的线程
                   
#### 不保证原子性
     由于线程切换太快，发生写覆盖，导致数据写丢失
     解决原子性： 
            使用AtomicInteger 使用CAS来确保原子性
            加锁
    
#### 禁止指令重排
     cpu在运行字节码指令的时候，会优化指令执行顺序，但是在多线程下面
     该关键字可以通过插入内存屏障来    保证不会发生指令重排问题的产生

### CAS
    自旋锁，比较并进行交换 ，线程内存每一次操作变量的时候，会和主内存的变量的值进行比较，来判断变量是否被修改
    unsafa:是cas的核心类，由于java无法直接访问底层系统，想要通过native关键字调用c++，unsafe是个后门，通过
    unsafe的方法直接通过指针访问内存，unsafe通过调用cpu的指令保证原子性
    AtomicReference 原子应用，可以包装对象，使得对象也具有原子性
    缺点：1、循环时间长，开销大 2、只能保证一个共享变量的原子性操作 3、会造成ada问题

### lock锁
    java类的api 通过reentrantLock 可以创建boolean类型的公平或者非公平锁，公平锁由于要通过队列保证顺序，所以会消耗性能，
    可以通过ReentrantReadWriteLock 来设置读写锁还有其他粒度更小的锁，可中断，可以通过condition精确唤醒
    
### Synchronized
    java关键字属于jvm依赖monitor，可以锁class，锁对象与锁代码块，不需要手动释放，是重锁
    等待不可以中断，不可以精确唤醒
    
### JUC帮助类
    CountDownLatch:计数帮助类，控制完成前提任务，才能完成最后的任务，做减法
    CyclicBarrier:计数帮助类，控制完成前提任务，才能完成最后的任务，做加法
    Semaphore:计数器帮助类 有增有减
    为了避免线程的虚假唤醒，都使用while
    
### 线程池
    线程池的底层是theadPoolExecutor
    核心线程数：常驻线程数
    最大线程数：线程池执行最大线程数
    存活时间：多余线程的存活时间
    时间单位：存活时间单位
    阻塞队列：任务队列
    线程工厂：生成线程
    策略：拒绝策略  4大策略 1、抛出异常  2、回提任务 3、抛出任务中最久的 4、丢弃

### 死锁
    1、互斥等待
    2、占用且等待
    3、不可强占
    4、循环等待  