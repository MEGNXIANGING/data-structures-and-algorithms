# 多线程与JVM(持续更新)
   代码都可以在src/main/java/jucJvm包下找到哦
<!-- GFM-TOC -->
* [JMM概览](#JMM概览)
* [volatile关键字](# volatile关键字)
* [CAS](# CAS)
* [lock锁](# lock锁)
* [Synchronized](# Synchronized)
* [参考] #https://www.bilibili.com/video/BV18b411M7xz?p=12
<!-- GFM-TOC --> 
### JMM概览
    java内存模型，俗称JMM(java memory model)本生是一种抽象的概念，它用于描述一种规范：
        1、线程解锁之前，必须把共享变量的值刷回主内存
        2、线程加锁之前，必须从主内存中读取最新的值到线程工作内存
        3、加锁解锁是同一种锁 
    主内存：所有的java线程共享的共同存储空间，线程之间的通信是由主线程来完成的
    线程工作内存：线程私有的存储空间，该线程工作时，先从主内存中获取想要操作的变量的值，线程操作以后再刷新回主内存
### volatile关键字
    volatile 被用于单例模式的双重检查中，他的防止指令重排被用到该模式中
    
#### 保证可见性
     线程工作要操作变量的结果及时刷新回主内存，并通知其他持有该变量的线程
                   
#### 不保证原子性
     由于线程切换太快，发生写覆盖，导致数据写丢失
     解决原子性： 
            使用AtomicInteger 使用CAS来确保原子性
            加锁
    
#### 禁止指令重排
     cpu在运行字节码指令的时候，会优化指令执行顺序，但是在多线程下面
     该关键字可以通过插入内存屏障来    保证不会发生指令重排问题的产生

### CAS
    自旋锁，比较并进行交换 ，线程内存每一次操作变量的时候，会和主内存的变量的值进行比较，来判断变量是否被修改
    unsafa:是cas的核心类，由于java无法直接访问底层系统，想要通过native关键字调用c++，unsafe是个后门，通过
    unsafe的方法直接通过指针访问内存，unsafe通过调用cpu的指令保证原子性
    AtomicReference 原子应用，可以包装对象，使得对象也具有原子性
    缺点：1、循环时间长，开销大 2、只能保证一个共享变量的原子性操作 3、会造成ada问题

### lock锁
    java类的api 通过reentrantLock 可以创建boolean类型的公平或者非公平锁，公平锁由于要通过队列保证顺序，所以会消耗性能，
    可以通过ReentrantReadWriteLock 来设置读写锁还有其他粒度更小的锁，可中断，可以通过condition精确唤醒
    阻塞式加锁（lock） 一直去加锁，直到加上为止
    中断式加锁（lockInterruptibly）  一直去加锁，但是加锁过程可以中断
    尝试性加锁（tryLock） 尝试去加锁，加不上返回false
    非公平锁：会造成线程饥饿，导致请求超时，在mq的设计中需要注意
    
    
### Synchronized
    java关键字属于jvm依赖monitor，可以锁class，锁对象与锁代码块，不需要手动释放，是重锁
    等待不可以中断，不可以精确唤醒
    
### JUC帮助类
    CountDownLatch:计数帮助类，控制完成前提任务，才能完成最后的任务，做减法
    CyclicBarrier:计数帮助类，控制完成前提任务，才能完成最后的任务，做加法
    Semaphore:计数器帮助类 有增有减
    为了避免线程的虚假唤醒，都使用while
    
### 线程池
    线程池的底层是theadPoolExecutor
    核心线程数：常驻线程数
    最大线程数：线程池执行最大线程数
    存活时间：多余线程的存活时间
    时间单位：存活时间单位
    阻塞队列：任务队列
    线程工厂：生成线程
    策略：拒绝策略  4大策略 1、抛出异常  2、回提任务 3、抛出任务中最久的 4、丢弃

### 死锁
    1、互斥等待
    2、占用且等待
    3、不可强占
    4、循环等待  
    
    
## jvm
    
### 类加载系统
    1、bootstrapClassLoader  引导类加载器 
    2、extensionClassLoader  拓展类加载器
    3、ApplicationClassLoader  应用类加载器
    4、可以自定义加载
    加载过程：loading->linking->init
    类加载器将在磁盘中.class文件加载到内存中，并生成实例
    双亲委派机制：父类加载失败，由子类加载
          1、避免类的重复加载 2、防止核心类被篡改，沙箱安全
    

### pc寄存器
   用于存储指令等相关相关信息，cpu只有把数据装载到寄存器才可以使用，存储下一条指令的地址
   由执行引擎来读取下一条指令，是线程私有的
   因为cpu不停切换线程，想要知道切换回来的时候，执行到哪里了
   jvm字节码解释器需要改变pc寄存器的值来明确下一条指令

### 虚拟机栈
    每一个线程在调用的时候都会生成一个虚拟机栈，其内部保存栈桢，对应Java方法的一次次调用，线程私有的
    
### 本地方法栈
    native 关键字调用c++接口，本地方法库存储了c++的函数库，本地方法栈用于管理本地方法的调用，线程私有 

### 堆
    堆区是java内存管理的核心区域，在java启动时被创建，其大小也就确定下来了，所有线程共享堆区，其作用是存储
    对象和数组，因为栈桢中保存引用指向堆中的内存地址，在方法结束以后，堆不会立刻被移除，仅仅在垃圾回收的时候被移除
#### 新生代（1/3）
      伊甸园：放新生对象，放满了就进行 young gc ，放到幸存者区，分配指针age
      s0： 每次gc会将s0 -》s1  或者s1 -》s0  谁空放谁，age++
      s1：

#### 养老代（2/3）  
      放从幸存者区过来的数据，当age到15的时候进入老年代，极少被垃圾回收    

#### 元空间（jdk7 永久区）
    